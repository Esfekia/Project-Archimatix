using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using AXGeometry;
//using AX.Generators;


/*
 * class for grouping a mesh, transform, and material
 * These are fed into the frame renderer for speed optimization 
 * to defer GameObject instantiation until the end of an edit operation.
 * 
 * AXMeshes are extremely temporary, coming into existance only during rapid-fire generation of 
 * objects, eg, when a handle is being dragged. Afterwards, and for most of the time, 
 * GameObject instantiations endure through time (only to be wiped away during a handles drag
 * when, once agin AXMeshes rule the roost.
 */
namespace AX
{
   
	public class AXMesh  {

		// In many cases, this mesh is a reference to a mesh shared by many AXMeshes.
		public Mesh mesh;

		/* This transMatrix is world 
	     * eg: this already is multiplied by the chain of PO trnasMatrices
		 */
		public Matrix4x4 transMatrix;


		/*	To work around a constraint in DrawMesh whereby negitive scale won't draw properly
		 *  we have to maintain a drawMesh for those meshes that are the product of symmetries, etc.
		 * The mesh is used for DrawMesh unless a drawMesh exists.
		 *
		 */

		[System.NonSerialized]
		private Mesh m_drawMesh = null;
		public  Mesh  drawMesh
			{
				get { 
					if (m_drawMesh != null)
						return m_drawMesh;
					return mesh; 
				}
				set { m_drawMesh = value; }
			}

		[System.NonSerialized]
		private Matrix4x4 m_drawMeshMatrix;
		public  Matrix4x4   drawMeshMatrix
		{
			get { 
				if (m_drawMesh != null)
					return m_drawMeshMatrix;
				return transMatrix; 
			}
			set { m_drawMeshMatrix = value; }
		}


		public bool getsCollider = true;

		// Use volume to calculate the mass of the Rigidbody associated with this mesh.
		public float volume;

		public Material mat;


		public float uScale = 1f;
		public float vScale = 1f;
		
		public float uShift = 0f;
		public float vShift = 0f;


		public bool rot_Y_rand = false;
		
		public bool hasContinuousUV = false;
		
		public string name = "axmesh";



		/* ParametricPbject that made this
		 * PO's stamp out AXMeshes. In a scene, there may be many AXMeshes that are generated by a given PO.
		 * 
		 * This maker gets added to the GameObject that this AXMesh becomes
		 */
		public AXParametricObject makerPO;

		public string subItemAddress; // for example, grid location in a GridRepeater


		/*
		 * An AXMesh has a list of children that it will use to later create a GameObject hierarchy
		 * 
		 */
		public List<AXMesh> children = new List<AXMesh>();








		public AXMesh() 
		{
			mesh 		= new Mesh();
			transMatrix = Matrix4x4.identity;
		}


		public AXMesh( Mesh m) 
		{
			mesh 		= m;
			transMatrix = Matrix4x4.identity;
		}
		public AXMesh( Mesh m, Matrix4x4 mx) 
		{
			mesh 		= m;
			transMatrix = mx;
		}
		public AXMesh( Mesh m, Matrix4x4 mx, Material _mat) 
		{
			mesh 		= m;
			transMatrix = mx;
			mat = _mat;
		}
		public AXMesh( Mesh m, Matrix4x4 mx, Material _mat, float u, float v) 
		{
			//Debug.Log("new axmesh: "+ uShift);
			mesh 		= m; 
			transMatrix = mx;
			mat 		= _mat;
			
			uShift = u;
			vShift = v;

			if (u != 0 || v != 0)
				shiftUVs();
			
		}
		public AXMesh( Mesh m, Matrix4x4 mx, Material _mat, float usc, float vsc, float ushft, float vshft ) 
		{
			//Debug.Log("new axmesh: "+ uShift);
			mesh 		= m; 
			transMatrix = mx;
			mat = _mat;
			
			uScale = usc;
			vScale = vsc;
			
			uShift = ushft;
			vShift = vshft;
		}
		
		public AXMesh( Mesh m, Matrix4x4 mx, Material _mat, AXTexCoords tex) 
		{
			//Debug.Log("new axmesh: "+ uShift);
			mesh 		= m; 
			transMatrix = mx;
			mat = _mat;
			
			uScale = tex.scale.x;
			vScale = tex.scale.y;
			
			uShift = tex.shift.x;
			vShift = tex.shift.y;
		}







		public static Mesh freezeWithMatrix(Mesh mesh, Matrix4x4 matrix)
		{
			// the workaround is to bake the scaling in...
			CombineInstance[] combinator 	= new CombineInstance[1];
			combinator[0].mesh  		= mesh;
			combinator[0].transform 		= matrix;
			Mesh transformedMesh  			= new Mesh();

			transformedMesh.CombineMeshes(combinator);


			return transformedMesh;
		}


		public static AXMesh combine(List<AXMesh> ax_meshes)
		{
			CombineInstance[] combinator 	= new CombineInstance[ax_meshes.Count];

			for (int i = 0; i < ax_meshes.Count; i++) {
				combinator[i].mesh  		= ax_meshes[i].mesh;
				combinator[i].transform 	= ax_meshes[i].drawMeshMatrix;
			}

			Mesh resultMesh = new Mesh ();
			resultMesh.CombineMeshes(combinator);
			resultMesh.RecalculateBounds ();
			resultMesh.RecalculateNormals ();
			resultMesh.RecalculateTangents ();

			return new AXMesh (resultMesh);

		}


		public static Mesh reverseTriangles(Mesh m)
		{
			Mesh tmpMesh = new Mesh();

			tmpMesh.triangles = tmpMesh.triangles.Reverse().ToArray();
			return tmpMesh;

		}


		public static Mesh cloneMesh(Mesh m)
		{
			Vector3[] vertices 		= (Vector3[]) 	m.vertices.Clone();
			Vector2[] uv 			= (Vector2[]) 	m.uv.Clone();
				int[] triangles 	= (int[]) 		m.triangles.Clone();
			Vector3[] normals 		= (Vector3[]) 	m.normals.Clone();

				
			Mesh tmpMesh = new Mesh();
			tmpMesh.vertices 	= vertices;
			tmpMesh.uv 			= uv;
			tmpMesh.triangles 	= triangles;
			tmpMesh.normals 	= normals;

			AXGeometry.Utilities.calculateMeshTangents(ref tmpMesh);
			return tmpMesh;


		}

		public Mesh meshClone()
		{
			Vector3[] vertices 		= (Vector3[]) 	mesh.vertices.Clone();
			Vector2[] uv 			= (Vector2[]) 	mesh.uv.Clone();
				int[] triangles 	= (int[]) 		mesh.triangles.Clone();
			Vector3[] normals 		= (Vector3[]) 	mesh.normals.Clone();

				
			Mesh tmpMesh = new Mesh();
			tmpMesh.vertices 	= vertices;
			tmpMesh.uv 			= uv;
			tmpMesh.triangles 	= triangles;
			tmpMesh.normals 	= normals;

			//AXGeometry.Utilities.calculateMeshTangents(ref tmpMesh);
			return tmpMesh;
		}
        public Mesh reverseMeshClone()
        {
            Vector3[] vertices = (Vector3[])mesh.vertices.Clone();
            Vector2[] uv = (Vector2[])mesh.uv.Clone();
            int[] triangles = (int[])mesh.triangles.Clone();


            Mesh tmpMesh = new Mesh();
            tmpMesh.vertices = vertices;
            tmpMesh.uv = uv;
            tmpMesh.triangles = triangles.Reverse().ToArray();
            tmpMesh.normals = mesh.normals;

            AXGeometry.Utilities.calculateMeshTangents(ref tmpMesh);
            return tmpMesh;
        }
        public static Mesh meshCloneReverse(Mesh mesh)
        {
            Vector3[] vertices = (Vector3[])mesh.vertices.Clone();
            Vector2[] uv = (Vector2[])mesh.uv.Clone();
            int[] triangles = (int[])mesh.triangles.Clone();


            Mesh tmpMesh = new Mesh();
            tmpMesh.vertices = vertices;
            tmpMesh.uv = uv;
            tmpMesh.triangles = triangles.Reverse().ToArray();
            tmpMesh.normals = mesh.normals;

            AXGeometry.Utilities.calculateMeshTangents(ref tmpMesh);
            return tmpMesh;
        }

        public AXMesh Clone()
		{


			AXMesh clone = new AXMesh( meshClone(), transMatrix, mat, uScale, vScale, uShift, vShift);

			clone.m_drawMesh 		= m_drawMesh;
			clone.m_drawMeshMatrix 	= m_drawMeshMatrix;

			clone.rot_Y_rand = rot_Y_rand;
			clone.name = name;
			clone.getsCollider = getsCollider;
			clone.makerPO = makerPO;

			return clone;
		}
		public AXMesh CloneReverse()
		{

			Vector3[] vertices 		= (Vector3[]) mesh.vertices.Clone();
			Vector2[] uv 			= (Vector2[]) mesh.uv.Clone();
				int[] triangles 	= (int[]) mesh.triangles.Clone();

				
			Mesh tmpMesh = new Mesh();

			tmpMesh.vertices = vertices;
			tmpMesh.uv = uv;
			tmpMesh.triangles = triangles.Reverse().ToArray();


			tmpMesh.RecalculateNormals();

			AXMesh clone = new AXMesh( tmpMesh, transMatrix, mat, uScale, vScale, uShift, vShift);
			
			clone.rot_Y_rand = rot_Y_rand;
			clone.name = name;
			clone.getsCollider = getsCollider;
				
			clone.makerPO = makerPO;
			
			return clone;
		}



		public static void transformWithMatrix(ref Mesh m, Matrix4x4 mx)
		{
			if (m == null || m.vertices == null)
				return;

			Vector3[] verts = new Vector3[m.vertices.Length];

			for (int i=0; i<verts.Length; i++)
			{
				verts[i] = mx.MultiplyPoint3x4(m.vertices[i]);

			}
			m.vertices = verts;
		}

		public AXMesh CloneTransformed(Matrix4x4 mx)
		{
			AXMesh clone = new AXMesh( meshClone(), transMatrix, mat, uScale, vScale, uShift, vShift);

			transformWithMatrix(ref clone.mesh, mx);
			clone.transMatrix = Matrix4x4.identity;

			transformWithMatrix(ref m_drawMesh, mx);
			clone.drawMeshMatrix 	= Matrix4x4.identity;


			clone.rot_Y_rand = rot_Y_rand;
			clone.name = name;
			clone.getsCollider = getsCollider;
			
			clone.makerPO = makerPO;

			return clone;
		}

		public AXMesh Clone(Matrix4x4 mx)
		{
			AXMesh clone = new AXMesh( mesh, transMatrix, mat, uScale, vScale, uShift, vShift);

			clone.transMatrix = mx;

			clone.m_drawMesh 		= m_drawMesh;
				clone.drawMeshMatrix 	= mx;

			clone.rot_Y_rand = rot_Y_rand;
			clone.name = name;
			clone.getsCollider = getsCollider;
			
			clone.makerPO = makerPO;

			return clone;
		}

		public AXMesh CloneReverse(Matrix4x4 mx)
		{
			Vector3[] vertices 		= (Vector3[]) 	mesh.vertices.Clone();
			Vector2[] uv 			= (Vector2[]) 	mesh.uv.Clone();
				int[] triangles 	= (int[]) 		mesh.triangles.Clone();
			Vector3[] normals   = (Vector3[])	mesh.normals.Clone();

			Mesh tmpMesh = new Mesh();
			tmpMesh.vertices 	= vertices;
			tmpMesh.uv 			= uv;
			tmpMesh.triangles 	= triangles.Reverse().ToArray();
			tmpMesh.normals		= normals;

			//tmpMesh.RecalculateNormals();
				//AXGeometry.Utilities.calculateMeshTangents(ref tmpMesh);

			AXMesh clone = new AXMesh( tmpMesh, transMatrix, mat, uScale, vScale, uShift, vShift);

			clone.transMatrix = mx;
			clone.rot_Y_rand = rot_Y_rand;
			clone.name = name;
			clone.getsCollider = getsCollider;
			
			clone.makerPO = makerPO;

			return clone;
		}


		public void addUVShift(float u, float v)
		{
			uShift += u;
			vShift += v;
		}

		public void shiftUVs()
		{//
			//Mesh m 		= mesh;//(Mesh) Mesh.Instantiate(mesh); 
			Vector2[] uv = new Vector2[mesh.uv.Length];
			
			for (int i=0; i<mesh.uv.Length; i++)
			{
				uv[i].x = mesh.uv[i].x + uShift;
				uv[i].y = mesh.uv[i].y + vShift;
			}
			mesh.uv = uv;


			//mesh = m;
		}



	}
}
